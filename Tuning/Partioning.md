# Partioning

- 테이블 파티셔닝은 테이블 데이터를 일정 기준으로 나누어 저장하는것
- 테이블을 파티셔닝하면 논리적으로는 테이블로 접근하지만, **물리적으로는 테이블 내의 각각의 파티션으로 접근한다.**
- 가나다 순으로 분류하는 것이 단일 테이블에서 인덱스를 사용하는 것이라면, **데이터베이스라는 분류에서 오라클이라는 세부 분류로 구분하는 것**은 파티션 테이블을 사용한 것의 예로 볼 수 있다.
- 범위를 줄여 원하는 데이터가 위치한 파티션만 읽도록 한다.
	- 전체 테이블 데이터를 모두 읽지 않아 뛰어는 성능 기대
- 관리 관점에서도 많은 데이터를 보관하다가 데이터를 삭제하려고 할때 **해당 파티션**만 지우면 된다.
- 데이터를 파티션 단위로 보관하기 때문에 추가, 삭제, 변경을 매우 빠르고 쉽게 할 수 있다.
	- DELETE 구문을 사용하는 것과 단순히 파티션을 드롭하는 것은 수행 속도뿐 아니라 그와 관련한 여러 관리 측면에서도 이점이 존재

## 🦢종류

### Range 파티션
- 가장 일반적
- 딱히 나눌 기준이 모호할 때, 주로 쌓이는 날짜를 기준으로 파티션
	- 월이든 분기든 각 파티션의 데이터의 분포가 갑자기 폭발적인 인기가 나왔다 사라지지 않는 이상 어느정도 비슷
- 파티션 키 컬럼을 정하기 매우 쉽다는 장점
- 'LESS THAN' 안의 값을 포함하지 않는다.
- 파티션 키 컬럼의 값이 범위를 가지고 있다.
	- 연속성이 있는 데이터를 갖는 특징이 있기 때문에, 파티션 키 컬럼을 가지고 **부등호 연산**이나 **BETWEEN 연산**을 했을 경우 해당 파티션 몇개만 읽을 수 있다.
	- ```WEHRE ORD_DT BETWEEN '120115' AND '120125' → 1월 파티션만 읽어 처리```
```sql
CREATE TABLE ORD_RANGE(
	...
	, ORD_DT VARCHAR2(8) NOT NULL
)
PARTITION BY RANGE(ORD_DT)
(
	PARTION P201201 VALUES LESS THAN ('201202') -- 20년 12월 1일 데이터
	, PARTION P201202 VALUES LESS THAN ('201203')
	...
	, PARTION P_DEFAULT VALUES LESS THAN (MAXVALUE)
);

-- P_DEFAULT 파티션에 MAXVALUE 값으로 만들어 두면, 
-- 파티션을 추가해야하지만 미처 못했을 경우 에러가 나는 상황을 방지하고자 할 때 사용한다.
-- 마지막 파티션 값보다 큰 경우의 데이터를 담을 수 있다.
```
<hr/>

### LIST 파티션
- 키 컬럼의 값이 설정한 값과 일치할 경우에 사용
- 키 컬럼을 잡기가 매우 어렵다.
	- 데이터 분포를 사람이 맞춰야 하기 때문에 각 파티본셔보다 분포가 크게 차이가 날 수 있다.

```sql
CREATE TABLE BILL_LIST(
	...
	, ORD_YN VARCHAR2(6) NOT NULL /* 청구년월 */
)
PARTITION BY LIST(ORD_YN)
(
	PARTION P201201 VALUES ('201201') -- 2012년 1월 데이터
	, PARTION P201202 VALUES ('201202') -- 2012년 2월 데이터
	...
	, PARTION P_DEFAULT VALUES (DEFAULT)
);


CREATE TABLE BOOK_LIST(
	...
	, BOOK_CATEGORY VARCHAR2(6) NOT NULL /* 카테고리 */
)
PARTITION BY LIST(BOOK_CATEGORY)
(
	PARTION P_CATEGORY01 VALUES ('소설','문학')
	, PARTION P_CATEGORY01 VALUES ('경제', '경영', '제테크') 
	, PARTINON P_CATEGROY02 VALUES ('사회', '과학')
	...
	, PARTION P_DEFAULT VALUES (DEFAULT)
);
-- 몇 개씩 묶어서 파티셔닝 가능 
-- 분류를 잘못하면 특정 파티션에 데이터가 몰릴 수 있다.
```
<hr/>

### HASH 파티션
- 키 컬럼의 값을 해시 함수를 이용해 지정한 파티션의 개수로 나누어 저장
- 오라클이 해시 함수로 데이터를 분산시켜 준다.
- 키 컬럼을 정할 때, 데이터 분포를 고려해야 한다.
- 같은 값이 많지 않은 컬럼을 사용해야 효과가 높다.
- 해쉬 조인과 마찬가지로 등치(=) 조건과 IN 조건만으로만 사용할 수 있고, 범위 조건인 부등호 조건과 BETWEEN 조건으로 사용될 가능성이 있는 컬럼은 되도록 사용하지 않는 것이 좋다.
- 문법적으로 파티션 개수만 지정한다.
```sql
CREATE TABLE ORD_DATE (
	ORD_NO NUMBER (10) NOT NULL
	, ...
)
PARTITION BY HASH (ORD_NO) PARTIONS 8; -- 8개의 파티션 개수 저징
```

## 🐇복합 파티셔닝
- 테이블을 파티션할 예정이라면 처음부터 복합 파티션을 고려해 보는게 좋다
- 각각의 파티션 특징이 제한적이고, 파티션을 사용하는 목적이 주로 파티션 단위로 무언가를 하기 때문
- 복합 파티션을 만들 때, **삭제와 조회** 기준으로 전략을 짜면 매우 좋다.
- 오라클은 복합 파티션을 메인 파티션과 서브 파티션으로 구분
	- 메인 파티션으로는 Range와 List 파티션만 가능
		- 12C 버전 이후로는 모든 방식 사용 가능
	- 서브 파티션은 모두 가능
```
1. 오래된 데이터를 삭제하는 일이 빈번하고, 특정 컬럼과 조인을 자주 하는 경우
  - Range(삭제기준컬럼) + Hash(조인기준컬럼)
  - List(삭제기준컬럼) + Hash(조인기준컬럼)
  - ex) 쇼핑몰의 주문 테이블 혹은 통신사의 청구서 테이블의 경우, 오래된 데이터는 무한정 보관X
     삭제 기준의 컬럼으로 메인 파티션으로 정하고, 조인기준으로 서브 파티션을 만든다.
2. 오래된 데이터를 삭제하는 업무와 지역별로 업무를 처리하는 경우
  - Range + List
  - List + List
  - ex) 자동차 판매인 경우 오래된 데이터를 삭제하고 판매일자와 지역 단위로 업무를 처리면, 
     메인 파티션을 판매월, 서브 파티션을 지역으로 만든다.
```

## 🐏인덱스 파티셔닝
- 인덱스도 테이블과 마찬가지로 나누어 보관할 수 있다.
- 인덱스는 테이블 데이터에 종속적이기 때문에 인덱스를 나눌 때도, 테이블을 나누는 전략을 잘 활용해야 한다.

### 비파티션 인덱스
- 인덱스는 파티션하지 않음
- ex) 00상사(List)
- 일반적으로 PK의 경우에는 논리적으로 비파티션 인덱스를 사용해야 완벽하게 무결성을 유지
- 간혹 성능을 위해 비파티션 인덱스를 만들 경우 아주 좋은 성능을 기대할 수 있지만, 테이블 파티션 삭제가 필요할 때, 잠시 데이터베이스 접속을 막야아하는 경우가 발생
<hr/>

### 로컬 파티션 인덱스
- 테이블 파티션과 같은 기준으로 인덱스를 나눔
- ex) 00상사(List)의 부서별(List)
- 테이블 파티션과 인덱스 파티션이 1:1로 대응
- 인덱스 생성 구문 제일 뒤에 LOCAL 이라는 키워드만 만들 수 있다.
- 테이블을 파티셔닝하면 대개 인덱스도 로컬 파티션 인덱스를 사용하려고 한다.
- 테이블 파티션을 삭제할 경우 해당 파티션의 인덱스도 동시에 삭제 가능
- 삭제 이슈가 있는 테이블에는 최대한 로컬 인덱스를 사용해야 한다.
<hr/>

### 글로벌 파티션 인덱스
- 테이블 파티션과는 다른 기준으로 인덱스를 나눔
- ex) 00상사(List)의 입사연도별(Range)
- ex) 주문일자를 키 컬럼으로 파티션했지만, 인덱스는 매장번호를 키 컬럼으로 나눈 경우
- 가장 큰 제약은 인덱스 키 컬럼을 항상 파티션 인덱스의 첫번째 컬럼으로 만들어야 한다.
- 글로벌 파티션 인덱스를 사용하는 경우는 거의 없다.

## 🐄파티션 Pruning
- 필요한 파티션만 접근하는 기능
	- 테이블 전체를 읽지 않고, 필요한 파티션만을 읽는다.
- Range 파티션으로 나누어진 테이블을 사용할 때 주의점
	- 키 컬럼에 저장된 값이 한 개 뿐이라는 것을 알 수 없다.
	- ex) ORD_YM - 201201
- 파티션 키 컬럼도 인덱스 컬럼과 마찬가지로 가공하면 오라클이 어느 파티션으로 액세스 해야할지 모른다. 필요하다면 값을 가공해야 한다.
	- UPDATE 구문이나 MERGE 구문에서도 마찬가지.