# JOIN (튜닝)
- 종류
	- NL(Nested Loop) Join
	- Sort Merge Join
	- Hash Join

## NL JOIN
```
두 테이블이 조인을 할 때, 드라이빙 테이블(outer 테이블)에서 읽은 결과를 
Inner 테이블로 건건이 조인을 시도하는 방식
```
- USE_NL(테이블명): 해당  테이블과 조인할 때 NL 조인 사용
- INNER 테이블에 조인키가 없으면 드라이빙 테이블에서 추출된 건마다 INNER 테이블을 반복적으로 엑세스 해야하는 단점
- INNER 테이블에 조인키가 있더라도 대량의 데이터 조인 발생시 많은 양의 랜덤 액세스를 해야하는 단점
- NL 조인은 랜덤 액세스 방식이라 비효율적으로 보이지만, 한 건씩 처리하기 때문에 처리 중간에 멈추는 경우(대표적으로 대용량 테이블에서 페이징 처리)에서 만큼은 적절한 인덱스만 있다면 극적으로 처리속도 개선의 여지가 있다.

**장점**
- NL 조인의 가장 큰 장점은 '중간에 멈출 수 있다'
	- 테이블을 스캔하다가 원하는 조건을 만족할 경우 더 이상 스캔을 하지 않기 때문

**단점**
- 조인을 시도할 때, 랜덤 엑세스 부하가 매우 높다는 점이다.
- 드라이빙 테이블에서 만족하는 결과가 많을 경우, Inner 테이블에 조인 컬럼 기준으로 인덱스가 있다고 하더라도 많은 랜덤 액세스는 엄청난 성능 저하를 가져온다.
	- 조인 컬럼과 연관된 인덱스가 없을 경우에는 드라이빙 테이블의 결과 건수 만큼 반복해서 읽어야 한다.
	- 만약 결과 건수가 1만 건이고, Inner 테이블의 총 데이터 건수가 1만 건이라면, 총 1억 건을 읽는 것과 같다.

**사용 조건**
- 온라인 트랜잭션이 많고, 부분범위처리(주로 페이징에서 사용)가 가능할 때
- 각 테이블의 데이터는 많지만, 추출할 대상이 되는 데이터 양이 많지 않을 때

**인덱스 설계**
- 드라이빙 테이블의 조인 컬럼을 인덱스에 추가해야 할 상황이라면 뒤에 배치해야 한다.
- 드라이빙 테이블의 인덱스에 조인 컬럼을 추가해도 테이블로 방문한다면, 조인 컬럼을 추가하지 않는 것이 좋다.
- **Inner 테이블의 조인 컬럼은 반드시 인덱스로 있어야 한다.**
	- 선두 컬럼으로 있는 것이 좋다.
	- Inner 테이블의 조건이 모두 등치 조건일 경우에는 순서 상관 X

**예제**
```sql
SELECT /*+ ORDERED USE_NL(E) */
	   *
FROM DEPT D
	 ,EMP E
WHERE 1 = 1
      AND D.DEPTNO = E.DEPTNO;

-- DEPT 테이블에서 데이터를 한 건 읽어서 EMP 테이블로 조인을 시도하고, 
--  조인에 성공하는 만큼을 결과 집합에 담는다. 
-- 다시 DEPT 테이블로 돌아가서 다음 한 건을 읽는다. 
--  EMP 테이블로 또 조인을 시도하고, 조인에 성공하는 만큼을 결과과 집합에 담는다.
```
- **ORDERED**: FROM 절에 나열된 순서대로 테이블을 읽도록 명령
- **USE_NL(E)**: E와 조인을할 때 NL 조인 사용

```sql
SELECT /*+ ORDERED USE_NL(E) */
	   A,*
	   ,B.*
FROM ITEM A
	 ,UITEM B
WHERE 1 = 1
      AND A.ITEM_ID = B.ITEM_ID     -- 1
      AND A.ITEM_TYPE_CD = '100100' -- 2
      AND A.SALE_YN = 'Y'           -- 3
      AND B.SALE_YN = 'Y';          -- 4
      
-- 동작순서: 2 -> 3 -> 1 -> 4

-- 최적의 인덱스
-- ITEM 테이블: ITEM_TYPE_CD + SALE_YN
-- UITEM 테이블: ITEM_ID + SALE_YN
```

## SORT MERGE JOIN
```
조인 시 두 테이블을 각각 조건에 맞게 먼저 읽고, 
읽은 두 테이블을 조인 컬럼을 기준으로 정렬해 놓고 조인을 수행하는 방식
```
- 각 테이블에서 조인 대상이 되는 조건을 먼저 걸러 대상이 되는 두 테이블 데이터를 만든 후에 조인을 시도 (NL 조인은 드라이빙 테이블만 읽어 조인 대상 제외)
- 두 번째부터는 첫 번째 시도한 만큼의 데이터는 조인 시도를 하지 않는다.
- 각 테이블을 한 번씩만 읽고 조인 시에는 PGA 공간에서 이루어지기 때문에, 조인으로 인한 랜덤 엑세스 부하는 없다고 할 수 있다.
- Outer 테이블에 정렬을 대신할 인덱스가 있다면 정렬을 시도하지 않는다.
- 오라클에서는 정렬을 PGA라는 공간에서 수행
	- PGA 공간은 프로세스에 할당된 독립된 공간이므로 SAG에 존재하는 버퍼 캐시를 사용하는 NL 조인에 비해 조인을 시도하는 데이터 접근이 더 빠르다.
	- SGA(System Global Area): 모든 사용자가 공유 가능하여 사용
	- PGA(Program Global Area): 사용자마다 공유하지 않고 개별적으로 사용
- 요새 자주 사용하지 않는다.
	- 해시 조인의 등장 때문
	- 조인과 직접적으로 관련이 없는 정렬을 하기 때문
	- 정렬 과정의 많은 CPU 부하

**장점**
- GROUP BY 혹은 ORDER BY로 이미 정렬된 상태라면, 정렬을 추가적으로 시도하지 않는다.
- 조인 조건이 등치(=) 조건이 아닌 경우 소트 머지 조인을 사용할 수 있다.
	- HASH 조인은 등치만 가능
	- NL 조인은 가능하지만, 너무 많은 랜덤 액세스가 부담스러움.
- 첫 번째 테이블에 한해 멈출 수 있다.
	- 정렬을 대신할 인덱스가 있다면, 정렬하지 않고, 해당 인덱스를 이용해 실시간으로 스캔해 조인을 시도한다.
	- 이 경우에는 중간에 멈춤 조건이 있을 경우 부분범위 처리를 할 수 있다.

**단점**
- 정렬에 대한 부담이 크고, 두 테이블을 PGA 내 소트 영역(Sort Area)에 위치 시켜야하는데, 테이블의 크기가 커서 PGA 공간을 넘을 경우 디스크 공간을 사용하여, 디스크 쓰기 부하까지 발생하여 성능 저하가 심하기 때문

**사용 조건**
- 첫 번째 테이블에 조인 컬럼 기준으로 인덱스가 있어 정렬 부하가 발생하지 않을 때
- GROUP BY 혹은 ORDER BY 등으로 이미 정렬한 서브 쿼리와 조인 시도 시 두 번째 테이블의 양이 적을 때
- 테이블의 양이 매우 커서 NL 조인이 힘들고, 조건이(=) 조인이 아니어서 해시 조인도 사용하기 힘들 때

**인덱스 설계**
- 정렬이 발생하지 않을 위치에 조인 컬럼을 반드시 추가해야 한다.
- Inner 테이블에도 조인 컬럼을 인덱스에 추가해 정렬을 하지 않도록 만드는 것이 좋다.

**예제**
 ```sql
SELECT /*+ ORDERED USE_MERGE(E) */
	   *
FROM DEPT D
	 ,EMP E
WHERE 1 = 1
	  AND D.DEPTNO = E.DEPTNO;

-- DEPT 테이블을 먼저 읽어 DEPTNO 컬럼 기준으로 정렬하고,
-- EMP 테이블을 읽어 DEPTNO 컬럼 기준으로 정렬한 다음,
-- 정렬된 각 테이블을 DEPTNO 컬럼으로 조인을 시도한다.
-- 이때, 두 번째부터는 첫 번째 시도한 만큼의 데이터는 조인 시도를 하지 않는다.
```
```sql
SELECT /*+ ORDERED USE_MERGE(B) */
	   *
FROM ITEM A
	 ,UITEM B
WHERE 1 = 1
      AND A.ITEM_ID = B.ITEM_ID     -- 1
      AND A.ITEM_TYPE_CD = '100100' -- 2
      AND A.SALE_YN = 'Y'           -- 3
      AND B.SALE_YN = 'Y';          -- 4

-- 동작순서: 2 -> 3 -> 4 -> 1

-- 최적의 인덱스
-- ITEM 테이블: ITEM_TYPE_CD + SALE_YN + ITEM_ID
-- UTIEM 테이블: SALE_YN + ITEM_ID -> 순서를 바꾸면 인덱스 풀스캔 발생
```
- 각각의 테이블에서 최종적으로 추려진 데이터를 조인키 지준으로 정렬하게 된다.
- 이때 정렬을 대신할 인덱스가 있으면 정렬을 위한 부하를 줄일 수 있다

## HASH JOIN
```
조인될 테이블 중 하나를 해시 테이블로 선정하여, 조인될 테이블의 조인 키값을 해시 함수의 반환 값으로 
비교하여 매치되는 결과 겂을 얻는 방식
```
- 오라클에서 해시 조인을 위해 두 테이블 중 **작은 테이블** 해시 맵을 만들고, **큰 테이블**을 읽어 해시 함수를 통해 해시 버킷을 찾아가 실제 데이터를 찾습니다.
	-	작은 테이블: Build Table
	-	큰 테이블: Probe Table
-	Build Table이 작아야 효율적이다.
	-	Build Input이 지나치게 큰 테이블로 선택되면 PGA 내 해시 영역 안에 적재가 힘들어진다.
	-	결국 디스크 공간을 사용하게 되고, 해시 조인의 성능이 크게 떨어진다.
-	해시 맵은 해시 함수가 반환하는 값으로 **해시 버킷**을 찾아 **해시 체인**에 연결하면서 만든다.
-	해시 함수가 반환하는 값으로 버킷을 찾고, 버킷에 할당된 해시 체인을 검색하면서 데이터를 찾아간다.
-	해시 맵에는 조인 컬럼과 SELECT 절에서 사용한 컬럼까지 포함
	-	꼭 필요한 컬럼만 기술하는 것이 PGA 사용량을 줄일 수 있다.

**장점**
-	전체 데이터를 정렬하는 것보다 해시 버킷을 만들고, 테이블을 스캔하면서 해당 버킷에 연결만 시키는 과정이 좀 더 부하가 낮을 것이다.
	-	해시맵도 PGA 내 해시 영역(Hash Area)에 생성되므로 크기가 작을 때 더욱 유리하다.

**단점**
- 많은 양의 CPU 부하
	- 온라인 트랜잭션이 많이 발생하는 시스템에서 해시 조인을 남발하면, 엄청난 CPU 부하가 발생

**사용 조건**
- 대용량 테이블을 조인 시도하는데 조인 컬럼에 적당한 인덱스가 없어 NL 조인이 힘들 때
- 조인 컬럼에 인덱스가 있지만 드라이빙 테이블의 결과 건수가 많아 Inner 테이블로 많은 양의 랜덤 액세스가 발생할 때
- 두 테이블의 양이 많아 소트 머지 조인 시도 시 정렬로 인한 부하가 클 때

**인덱스 설계**
- 조인 컬럼이 인덱스에 포함되지 않아도 성능상의 손익은 없다.
	- 다만 조인 컬림이 인덱스에 포함되어 테이블로의 방문을 막을 수 있다면 고려해볼 만하다.

**예제**
```sql
SELECT /*+ ORDERED USE_HASH(E) */
	   *
FROM DEPT D
	 ,EMP E
WHERE 1 = 1
      AND D.DEPTNO = E.DEPTNO
```
```sql
SELECT /*+ ORDERED USE_HASH(B) */
	   *
FROM ITEM A
	 ,UITEM B
WHERE 1 = 1
      AND A.ITEM_ID = B.ITEM_ID     -- 1
      AND A.ITEM_TYPE_CD = '100100' -- 2
      AND A.SALE_YN = 'Y'           -- 3
      AND B.SALE_YN = 'Y';          -- 4  

-- 동작순서: 2 -> 3 -> 1 -> 4
-- A 테이블을 Build Input으로 선택해 해시 맵을 만들고,
-- B 테이블을 Probe Input으로 선택해 A 테이블을 읽으면서 조인을 시도한다.

-- 최적의 인덱스
-- ITEM 테이블: ITEM_TYPE_CD + SALE_YN
-- UTIEM 테이블: SALE_YN
```
- 두 개의 테이블만으로 해시 조인을 할 경우 ORDERED 또는 LEADING 힌트를 사용해서 Build Input을 지정
- 세 개 이상일 경우 SWAP_JOIN_INPUTS(테이블명) 사용
	-	```USE_HASH(E) SWAP_JOIN_INPUTS(E) ```


